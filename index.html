<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- å®£å‘Šé€™æ˜¯ä¸€å€‹ PWA æ‡‰ç”¨ç¨‹å¼ -->
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#2E7D32">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="./icon.svg">
    
    <title>åœ“æ»¾æ»¾è¶³çƒ - ä¸–ç•Œå·¡è¿´ç‰ˆ</title>
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: #111; display: flex;
            justify-content: center; align-items: center;
            overflow: hidden; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none; -webkit-user-select: none;
        }
        #game-container {
            position: relative;
            display: flex; justify-content: center; align-items: center;
            width: 100%; height: 100%;
            background-color: #2E7D32;
        }
        canvas {
            max-width: 100%; max-height: 100%;
            object-fit: contain;
            box-shadow: 0 0 30px rgba(0,0,0,0.9);
            touch-action: none;
        }
        
        .overlay-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: flex; flex-direction: column; justify-content: space-evenly; align-items: center;
            z-index: 50; transition: opacity 0.3s;
            pointer-events: auto;
        }
        .lobby-title {
            color: white; font-size: 8vw; font-weight: 900;
            text-shadow: 0 0 20px rgba(76, 175, 80, 0.8); margin: 0;
            letter-spacing: 2px; position: relative; z-index: 10;
        }

        .top-btn {
            position: absolute; top: 20px; 
            font-size: 6vw; background: rgba(255,255,255,0.15);
            border-radius: 50%; width: 12vw; height: 12vw;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; z-index: 60; transition: 0.2s;
            border: 2px solid rgba(255,255,255,0.3); color: white;
        }
        .top-btn:active { transform: scale(0.9); background: rgba(255,255,255,0.3); }
        
        #settings-btn { right: 20px; }
        /* ã€æ–°å¢ã€‘å…¨è¢å¹•åˆ‡æ›æŒ‰éˆ•ï¼Œé›™ä¿éšªæ©Ÿåˆ¶ */
        #fullscreen-btn { left: 20px; }

        .close-btn {
            position: absolute; top: 20px; left: 20px;
            font-size: 6vw; background: rgba(255,82,82,0.3); color: white;
            border-radius: 50%; width: 12vw; height: 12vw;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; border: 2px solid rgba(255,82,82,0.6); z-index: 60;
        }
        .close-btn:active { transform: scale(0.9); }

        #audio-btn {
            position: absolute; top: 20px; right: 20px;
            font-size: 6vw; background: rgba(255,255,255,0.15);
            border-radius: 50%; width: 12vw; height: 12vw;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; z-index: 60; transition: 0.2s;
            border: 2px solid rgba(255,255,255,0.3);
        }
        #audio-btn:active { transform: scale(0.9); background: rgba(255,255,255,0.3); }

        .player-select-area {
            width: 95%; background: rgba(255,255,255,0.1);
            border-radius: 20px; padding: 10px 0; border: 2px solid rgba(255,255,255,0.2);
            text-align: center; position: relative; z-index: 10;
        }
        .flip-180 { transform: rotate(180deg); }

        .player-label { color: white; font-size: 4.5vw; font-weight: bold; margin-bottom: 5px; }
        
        .carousel-wrapper { display: flex; align-items: center; justify-content: center; width: 100%; }
        .nav-arrow {
            background: rgba(255,255,255,0.15); border: none; color: white; font-size: 5vw;
            border-radius: 50%; width: 10vw; height: 10vw; display: flex;
            align-items: center; justify-content: center; cursor: pointer; transition: 0.2s;
            margin: 0 5px; flex-shrink: 0; z-index: 10;
        }
        .nav-arrow:active { background: rgba(255,255,255,0.4); transform: scale(0.9); }
        
        .cards-scroll { 
            display: flex; gap: 15px; overflow-x: auto; scroll-behavior: smooth;
            scroll-snap-type: x mandatory; padding: 5px 10px; width: 65%;
            scrollbar-width: none; 
        }
        .cards-scroll::-webkit-scrollbar { display: none; }
        
        .char-card {
            flex: 0 0 45%; padding: 8px; border-radius: 15px;
            background: rgba(0,0,0,0.5); border: 3px solid transparent; transition: 0.2s;
            scroll-snap-align: center; cursor: pointer; position: relative; z-index: 10;
        }
        .char-card.selected {
            background: rgba(255,255,255,0.2);
            border-color: #4CAF50; box-shadow: 0 0 15px rgba(76,175,80,0.8);
            transform: scale(1.05);
        }
        .char-card p { color: white; margin: 5px 0 0 0; font-size: 3.2vw; font-weight: bold; pointer-events: none; }
        .char-card .sub-text { font-size: 2vw; color: #ccc; font-weight: normal; pointer-events: none; }
        .char-preview { width: 100%; height: 50px; position: relative; pointer-events: none; }
        
        .char-desc-box {
            color: #FFEB3B; font-size: clamp(13px, 3.5vw, 16px);
            margin: 10px auto 5px; width: 90%; min-height: 40px;
            line-height: 1.4; text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            display: flex; align-items: center; justify-content: center;
            font-weight: bold;
        }

        .map-card { flex: 0 0 60%; }
        .map-card.selected { border-color: #FFEB3B; box-shadow: 0 0 20px rgba(255,235,59,0.6); }
        .map-icon { font-size: 10vw; margin: 10px 0; pointer-events: none; }
        
        .mode-buttons { display: flex; gap: 15px; width: 90%; justify-content: center; margin-bottom: 20px; position: relative; z-index: 10; }
        .btn {
            flex: 1; padding: 15px 10px; font-size: 4.5vw; font-weight: 900;
            color: white; border: none; border-radius: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); transition: transform 0.1s; cursor: pointer;
            position: relative; z-index: 10;
        }
        .btn-classic { background: linear-gradient(45deg, #4CAF50, #2E7D32); }
        .btn-item { background: linear-gradient(45deg, #FF9800, #F57C00); }
        .btn:active { transform: scale(0.95); }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10; display: block;
        }
        .half-screen {
            position: absolute; width: 100%; height: 50%; left: 0;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .top-half { top: 0; transform: rotate(180deg); }
        .bottom-half { bottom: 0; }

        .score-bg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 50vw; font-weight: 900; opacity: 0.15;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            margin: 0; pointer-events: none;
        }
        .score-bump { transform: translate(-50%, -50%) scale(1.2) !important; opacity: 0.4; }
        .score-p1 { color: #ff5252; } 
        .score-p2 { color: #4dd0e1; }

        #round-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(2px);
            z-index: 15; pointer-events: none; transition: opacity 0.3s;
        }
        #round-overlay.hidden { opacity: 0; }

        .countdown-text { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 15vw; font-weight: 900; color: white; transition: transform 0.2s; z-index: 20; 
        }
        
        .goal-message {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.5);
            font-size: 10vw; font-weight: 900; color: white; text-shadow: 0 5px 15px rgba(0,0,0,0.8); 
            opacity: 0; transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index: 25;
        }
        .show-goal { opacity: 1 !important; transform: translate(-50%, -50%) scale(1) !important; }
        
        .event-warning {
            position: absolute; top: 20%; width: 100%; text-align: center;
            font-size: 6vw; font-weight: 900; color: #00E5FF;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.8); opacity: 0;
            transition: opacity 0.3s; z-index: 20; letter-spacing: 5px;
        }
        .show-warning { opacity: 1 !important; animation: blink 0.5s infinite alternate; }
        @keyframes blink { from { opacity: 1; } to { opacity: 0.3; } }
        
        .match-point-info {
            position: absolute; bottom: 15%; width: 100%; text-align: center;
            color: #FFEB3B; font-size: 4vw; font-weight: bold; z-index: 20;
        }
        .d-none { display: none !important; }

    </style>
</head>
<body>

<!-- PWA Service Worker è¨»å†Š -->
<script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('./sw.js').then(reg => {
                console.log('SW registered!', reg);
            }).catch(err => console.log('SW registration failed', err));
        });
    }
</script>

<div id="game-container">
    <canvas id="gameCanvas" width="768" height="1152"></canvas>
    
    <!-- é¸è§’å¤§å»³ -->
    <div id="lobby-layer" class="overlay-layer">
        <!-- é›™ä¿éšªï¼šæ‰‹å‹•å…¨è¢å¹•æŒ‰éˆ• -->
        <div id="fullscreen-btn" class="top-btn" onclick="window.toggleFullscreen()">â›¶</div>
        <div id="settings-btn" class="top-btn" onclick="window.openSettings()">âš™ï¸</div>
        
        <div class="player-select-area flip-180" style="border-color: rgba(255,82,82,0.5); margin-bottom: auto; margin-top: 15%;">
            <div class="player-label" style="color: #ff5252;">ä¸Šæ–¹ç©å®¶ (P1)</div>
            <div class="carousel-wrapper">
                <button class="nav-arrow" onclick="window.scrollMenu('p1-scroll', -1)">â®</button>
                <div class="cards-scroll" id="p1-scroll">
                    <div class="char-card selected" id="p1-char1" onclick="window.selectChar(1, 1)"><canvas class="char-preview" id="pre-p1-1"></canvas><p>é€Ÿåº¦</p><p class="sub-text">å¿«/è¼•</p></div>
                    <div class="char-card" id="p1-char2" onclick="window.selectChar(1, 2)"><canvas class="char-preview" id="pre-p1-2"></canvas><p>åŠ›é‡</p><p class="sub-text">æ…¢/é‡</p></div>
                    <div class="char-card" id="p1-char3" onclick="window.selectChar(1, 3)"><canvas class="char-preview" id="pre-p1-3"></canvas><p>ç‹™æ“Š</p><p class="sub-text">è‡ªå‹•è½‰å½</p></div>
                    <div class="char-card" id="p1-char4" onclick="window.selectChar(1, 4)"><canvas class="char-preview" id="pre-p1-4"></canvas><p>å·¨ç„¡éœ¸</p><p class="sub-text">çµ•å°é˜²ç¦¦</p></div>
                    <div class="char-card" id="p1-char5" onclick="window.selectChar(1, 5)"><canvas class="char-preview" id="pre-p1-5"></canvas><p>ç£åŠ›</p><p class="sub-text">éš”å±±æ‰“ç‰›</p></div>
                    <div class="char-card" id="p1-char6" onclick="window.selectChar(1, 6)"><canvas class="char-preview" id="pre-p1-6"></canvas><p>å¾‹å¸«</p><p class="sub-text">ä¿è­·ä»¤</p></div>
                </div>
                <button class="nav-arrow" onclick="window.scrollMenu('p1-scroll', 1)">â¯</button>
            </div>
            <div id="p1-desc" class="char-desc-box"></div>
        </div>

        <h1 class="lobby-title" style="margin: 2vh 0;">åœ“æ»¾æ»¾è¶³çƒ</h1>

        <div class="player-select-area" style="border-color: rgba(77,208,225,0.5); margin-top: auto; margin-bottom: 2vh;">
            <div class="player-label" style="color: #4dd0e1;">ä¸‹æ–¹ç©å®¶ (P2)</div>
            <div class="carousel-wrapper">
                <button class="nav-arrow" onclick="window.scrollMenu('p2-scroll', -1)">â®</button>
                <div class="cards-scroll" id="p2-scroll">
                    <div class="char-card" id="p2-char1" onclick="window.selectChar(2, 1)"><canvas class="char-preview" id="pre-p2-1"></canvas><p>é€Ÿåº¦</p><p class="sub-text">å¿«/è¼•</p></div>
                    <div class="char-card selected" id="p2-char2" onclick="window.selectChar(2, 2)"><canvas class="char-preview" id="pre-p2-2"></canvas><p>åŠ›é‡</p><p class="sub-text">æ…¢/é‡</p></div>
                    <div class="char-card" id="p2-char3" onclick="window.selectChar(2, 3)"><canvas class="char-preview" id="pre-p2-3"></canvas><p>ç‹™æ“Š</p><p class="sub-text">è‡ªå‹•è½‰å½</p></div>
                    <div class="char-card" id="p2-char4" onclick="window.selectChar(2, 4)"><canvas class="char-preview" id="pre-p2-4"></canvas><p>å·¨ç„¡éœ¸</p><p class="sub-text">çµ•å°é˜²ç¦¦</p></div>
                    <div class="char-card" id="p2-char5" onclick="window.selectChar(2, 5)"><canvas class="char-preview" id="pre-p2-5"></canvas><p>ç£åŠ›</p><p class="sub-text">éš”å±±æ‰“ç‰›</p></div>
                    <div class="char-card" id="p2-char6" onclick="window.selectChar(2, 6)"><canvas class="char-preview" id="pre-p2-6"></canvas><p>å¾‹å¸«</p><p class="sub-text">ä¿è­·ä»¤</p></div>
                </div>
                <button class="nav-arrow" onclick="window.scrollMenu('p2-scroll', 1)">â¯</button>
            </div>
            <div id="p2-desc" class="char-desc-box"></div>
        </div>

        <div class="mode-buttons" style="margin-bottom: 5vh;">
            <button class="btn btn-classic" onclick="window.startGame('CLASSIC')">âš½ ç¶“å…¸è³½</button>
            <button class="btn btn-item" onclick="window.startGame('ITEM')">ğŸ” é“å…·è³½</button>
        </div>
    </div>

    <!-- å ´åœ°è¨­å®šé é¢ -->
    <div id="settings-layer" class="overlay-layer d-none" style="z-index: 70; background: rgba(0,0,0,0.95);">
        <div class="close-btn" onclick="window.closeSettings()">âœ–</div>
        <h1 class="lobby-title" style="color: #FFEB3B;">ä¸–ç•Œå·¡è¿´</h1>
        
        <div class="player-select-area" style="border-color: #FFEB3B; padding: 20px 0;">
            <div class="player-label" style="color: #FFEB3B;">é¸æ“‡æ¯”è³½å ´åœ°</div>
            <div class="carousel-wrapper">
                <button class="nav-arrow" onclick="window.scrollMenu('map-scroll', -1)">â®</button>
                <div class="cards-scroll" id="map-scroll" style="width: 75%;">
                    <div class="char-card map-card selected" id="map-1" onclick="window.selectMap(1)">
                        <div class="map-icon">âš½</div>
                        <p>ç¶“å…¸è‰åœ°</p><p class="sub-text">æ¨™æº–æ‘©æ“¦åŠ›</p>
                    </div>
                    <div class="char-card map-card" id="map-2" onclick="window.selectMap(2)">
                        <div class="map-icon">â„ï¸</div>
                        <p>åŒ—æµ·é“é›ªç¥­</p><p class="sub-text">çªç™¼æš´é¢¨é›ª</p>
                    </div>
                    <div class="char-card map-card" id="map-3" onclick="window.selectMap(3)">
                        <div class="map-icon">ğŸŒ‡</div>
                        <p>é«˜é›„ 85 å¤§æ¨“</p><p class="sub-text">è¼•è»Œç¶“é</p>
                    </div>
                    <div class="char-card map-card" id="map-4" onclick="window.selectMap(4)">
                        <div class="map-icon">ğŸ„</div>
                        <p>äºé¦¬éœå¢æ—</p><p class="sub-text">å½ˆåŠ›æ¯’è˜‘è‡é™£</p>
                    </div>
                    <div class="char-card map-card" id="map-5" onclick="window.selectMap(5)">
                        <div class="map-icon">ğŸŒº</div>
                        <p>å°å°¼ å©†ç¾…æ´²</p><p class="sub-text">å·¨å‹é£ŸäººèŠ±</p>
                    </div>
                    <div class="char-card map-card" id="map-6" onclick="window.selectMap(6)">
                        <div class="map-icon">ğŸŒªï¸</div>
                        <p>æ–°ç«¹ ç«¹åŒ—</p><p class="sub-text">ç‹‚æš´ä¹é™é¢¨</p>
                    </div>
                </div>
                <button class="nav-arrow" onclick="window.scrollMenu('map-scroll', 1)">â¯</button>
            </div>
        </div>
        <p style="color:#aaa; font-size:3.5vw; width:80%; text-align:center;">é¸æ“‡åœ°åœ–å¾Œé»æ“Šå·¦ä¸Šè§’è¿”å›å¤§å»³</p>
    </div>

    <div id="round-overlay" class="d-none"></div>
    <div id="ui-layer" class="d-none">
        
        <div id="audio-btn" onclick="window.toggleAudio()" style="pointer-events: auto;">ğŸ”‡</div>

        <div class="half-screen top-half">
            <div class="score-bg score-p1" id="score-bg-p1">0</div>
            <div class="event-warning"></div>
            <div id="mpi-p1" class="match-point-info d-none">å…ˆå¾— 3 åˆ†è€…ç²å‹</div>
            <div class="countdown-text d-none">3</div>
            <div class="goal-message">GOAL!</div>
        </div>

        <div class="half-screen bottom-half">
            <div class="score-bg score-p2" id="score-bg-p2">0</div>
            <div class="event-warning"></div>
            <div id="mpi-p2" class="match-point-info d-none">å…ˆå¾— 3 åˆ†è€…ç²å‹</div>
            <div class="countdown-text d-none">3</div>
            <div class="goal-message">GOAL!</div>
        </div>
    </div>
</div>

<script>
    // ==========================================
    // 0. å…¨è¢å¹•åˆ‡æ›åŠŸèƒ½ (Fullscreen API)
    // ==========================================
    window.toggleFullscreen = () => {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                console.warn("Fullscreen error:", err.message);
            });
        } else {
            if (document.exitFullscreen) document.exitFullscreen();
        }
    };

    // ==========================================
    // 0. éŸ³æ•ˆç³»çµ± (Web Audio API)
    // ==========================================
    class AudioEngine {
        constructor() {
            this.ctx = null;
            this.isMuted = true; 
            this.bgmPlaying = false;
            this.bgmTimer = null;
        }
        init() {
            if (this.ctx) return;
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
        }
        toggleMute() {
            this.isMuted = !this.isMuted;
            if (!this.isMuted) {
                this.init();
                if (this.ctx.state === 'suspended') this.ctx.resume();
                if (!this.bgmPlaying && gameState === 'PLAYING') this.startBGM();
            } else {
                this.stopBGM();
            }
            return !this.isMuted;
        }
        playTone(freq, type, duration, vol=0.1, slideFreq=null) {
            if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            if (slideFreq) osc.frequency.exponentialRampToValueAtTime(slideFreq, this.ctx.currentTime + duration);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            osc.connect(gain); gain.connect(this.ctx.destination);
            osc.start(); osc.stop(this.ctx.currentTime + duration);
        }
        playKick() { this.playTone(600, 'sine', 0.2, 0.3, 100); }       
        playBounce() { this.playTone(150, 'square', 0.1, 0.1, 50); }     
        playPostHit() { this.playTone(800, 'triangle', 0.15, 0.2, 400); }
        playPigHit() { this.playTone(200, 'sine', 0.2, 0.2, 80); }       
        playTick() { this.playTone(440, 'square', 0.1, 0.05); }          
        playStart() { this.playTone(880, 'square', 0.3, 0.1); }          
        playGoal() {
            if (this.isMuted || !this.ctx) return;
            let now = this.ctx.currentTime;
            const notes = [523.25, 659.25, 783.99, 1046.50]; 
            notes.forEach((freq, i) => {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(0.15, now + i * 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.2);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(now + i * 0.1); osc.stop(now + i * 0.1 + 0.2);
            });
        }
        startBGM() {
            if (this.isMuted || !this.ctx || this.bgmPlaying) return;
            this.bgmPlaying = true;
            this.playBGMNote();
        }
        stopBGM() {
            this.bgmPlaying = false;
            if (this.bgmTimer) clearTimeout(this.bgmTimer);
        }
        playBGMNote() {
            if (!this.bgmPlaying) return;
            const scale = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25]; 
            const freq = scale[Math.floor(Math.random() * scale.length)];
            this.playTone(freq, 'sine', 1.0, 0.03); 
            const nextTime = 400 + Math.random() * 400;
            this.bgmTimer = setTimeout(() => this.playBGMNote(), nextTime);
        }
    }
    const audio = new AudioEngine();

    // ==========================================
    // 1. å…¨åŸŸå¸¸æ•¸èˆ‡ç‹€æ…‹è®Šæ•¸å®£å‘Š
    // ==========================================
    const GAME_WIDTH = 768;
    const GAME_HEIGHT = 1152;
    const WINNING_SCORE = 3; 
    const GOAL_LEFT = GAME_WIDTH * 0.3;
    const GOAL_RIGHT = GAME_WIDTH * 0.7;

    let canvas, ctx, bgCanvas, bgCtx;
    let player1, player2, ball; 
    let gameState = 'LOBBY'; 
    let gameMode = 'CLASSIC'; 
    let scores = { p1: 0, p2: 0 };
    let shakeAmount = 0;
    
    let selectedChars = { p1: 1, p2: 2 };
    let currentMap = 1; 
    
    let particles = [];
    let windParticles = []; 
    let vortexParticles = [];
    let shockwaves = []; 
    let countdownInterval = null; 
    let itemsOnField = [];
    let itemSpawnTimer = 0;
    let popcornWalls = { p1: 0, p2: 0 }; 

    let mushrooms = [];
    let cannibalPlants = []; 

    let mapState = { windTimer: 480, windActive: 0, windDir: 1, lrtTimer: 600, lrtActive: 0, lrtX: -850, vortexTimer: 600, vortexActive: 0 };

    const charDescriptions = {
        1: "ã€é€Ÿåº¦å‹ã€‘ç§»å‹•å¦‚é¢¨ï¼é©åˆå¿«é€Ÿè·‘ä½æ””æˆªï¼Œä½†è¸¢åŠ›è¼ƒå¼±ã€‚",
        2: "ã€åŠ›é‡å‹ã€‘é‡å¦‚æ³°å±±ï¼ç§»å‹•ç·©æ…¢ï¼Œä½†å¤§è…³ä¸€é–‹èƒ½è½ŸéåŠå ´ã€‚",
        3: "ã€ç‹™æ“Šå‹ã€‘è‡ªå¸¶è¿½è¹¤ï¼è¸¢å‡ºçš„çƒæœƒè‡ªå‹•è½‰å½é£›å‘å°æ‰‹çƒé–€ã€‚",
        4: "ã€å·¨ç„¡éœ¸ã€‘å˜†æ¯ä¹‹ç‰†ï¼é«”ç©é¾å¤§ï¼Œåœåœ¨çƒé–€å‰å°±æ˜¯æœ€å¼·é˜²å®ˆã€‚",
        5: "ã€ç£åŠ›å‹ã€‘éš”ç©ºå–ç‰©ï¼è‡ªå¸¶å¼•åŠ›ç£å ´ï¼Œä¸ç”¨ç¢°åˆ°ä¹Ÿèƒ½æŠŠçƒå¸éä¾†ã€‚",
        6: "ã€å¾‹å¸«ã€‘ä¾æ³•ä¿è­·ï¼è¸¢çƒé™„å¸¶1.5ç§’é˜²è­·ç½©ï¼Œé è¿‘çš„å°æ‰‹æœƒå½ˆé£›ã€‚"
    };

    bgCanvas = document.createElement('canvas');
    bgCanvas.width = GAME_WIDTH;
    bgCanvas.height = GAME_HEIGHT;
    bgCtx = bgCanvas.getContext('2d');

    // ==========================================
    // 2. UI å‡½æ•¸å®£å‘Š
    // ==========================================
    window.scrollMenu = function(id, direction) {
        const el = document.getElementById(id);
        if (!el) return;
        const scrollAmount = el.clientWidth * 0.55 * direction; 
        if (el.scrollBy) { el.scrollBy({ left: scrollAmount, behavior: 'smooth' }); } 
        else { el.scrollLeft += scrollAmount; }
    }
    window.openSettings = function() { document.getElementById('lobby-layer').classList.add('d-none'); document.getElementById('settings-layer').classList.remove('d-none'); }
    window.closeSettings = function() { document.getElementById('settings-layer').classList.add('d-none'); document.getElementById('lobby-layer').classList.remove('d-none'); }
    window.selectMap = function(mapId) {
        currentMap = mapId;
        [1,2,3,4,5,6].forEach(i => { let m = document.getElementById('map-'+i); if(m) m.classList.remove('selected'); });
        document.getElementById('map-'+mapId).classList.add('selected');
        drawBeautifulBackground(); 
    }
    window.selectChar = function(player, type) {
        if (player === 1) {
            selectedChars.p1 = type;
            for(let i=1; i<=6; i++) { let e = document.getElementById('p1-char'+i); if(e) e.classList.remove('selected'); }
            document.getElementById('p1-char' + type).classList.add('selected');
            document.getElementById('p1-desc').innerText = charDescriptions[type];
        } else {
            selectedChars.p2 = type;
            for(let i=1; i<=6; i++) { let e = document.getElementById('p2-char'+i); if(e) e.classList.remove('selected'); }
            document.getElementById('p2-char' + type).classList.add('selected');
            document.getElementById('p2-desc').innerText = charDescriptions[type];
        }
    }
    function getCanvasPos(clientX, clientY) {
        if (!canvas) return { x: 0, y: 0 };
        const rect = canvas.getBoundingClientRect();
        return { x: (clientX - rect.left) * (GAME_WIDTH / rect.width), y: (clientY - rect.top) * (GAME_HEIGHT / rect.height) };
    }
    function createConfettiAt(x, y, color) {
        for(let i=0; i<30; i++){ particles.push({ x: x, y: y, vx: (Math.random()-0.5)*15, vy: (Math.random()-0.5)*15, life: 1.5, color: color }); }
    }
    function showEventWarning(text) {
        document.querySelectorAll('.event-warning').forEach(w => {
            w.innerText = text; w.classList.add('show-warning'); 
            setTimeout(() => w.classList.remove('show-warning'), 2000);
        });
    }
    function updateScoreDisplay() {
        const s1 = document.getElementById('score-bg-p1');
        const s2 = document.getElementById('score-bg-p2');
        if(s1) { s1.innerText = scores.p1; s1.classList.add('score-bump'); setTimeout(() => s1.classList.remove('score-bump'), 300); }
        if(s2) { s2.innerText = scores.p2; s2.classList.add('score-bump'); setTimeout(() => s2.classList.remove('score-bump'), 300); }
    }
    window.startGame = function(mode) {
        audio.init(); 
        gameMode = mode; 
        document.getElementById('lobby-layer').classList.add('d-none');
        document.getElementById('ui-layer').classList.remove('d-none');
        scores = { p1: 0, p2: 0 };
        updateScoreDisplay();
        initGameMechanics();
    }
    window.returnToLobby = function() {
        audio.stopBGM();
        document.getElementById('ui-layer').classList.add('d-none');
        document.getElementById('lobby-layer').classList.remove('d-none');
        gameState = 'LOBBY';
        particles = []; windParticles = []; vortexParticles = []; shockwaves = []; itemsOnField = []; popcornWalls = { p1: 0, p2: 0 }; mushrooms = []; cannibalPlants = [];
        if (countdownInterval) clearInterval(countdownInterval);
    }
    function startRoundCountdown() {
        audio.stopBGM();
        gameState = 'COUNTDOWN'; player1.reset(); player2.reset(); ball.reset();
        itemsOnField = []; itemSpawnTimer = 300; popcornWalls = { p1: 0, p2: 0 };
        windParticles = []; vortexParticles = []; shockwaves = [];
        mapState.windTimer = 480; mapState.windActive = 0; mapState.lrtTimer = 600; mapState.lrtActive = 0; mapState.lrtX = -850; mapState.vortexTimer = 600; mapState.vortexActive = 0; 
        mushrooms = []; cannibalPlants = [];
        if (currentMap === 4) { mushrooms = [{ x: GAME_WIDTH * 0.3, y: GAME_HEIGHT * 0.42, r: 45, hit: 0 }, { x: GAME_WIDTH * 0.7, y: GAME_HEIGHT * 0.42, r: 45, hit: 0 }, { x: GAME_WIDTH * 0.3, y: GAME_HEIGHT * 0.58, r: 45, hit: 0 }, { x: GAME_WIDTH * 0.7, y: GAME_HEIGHT * 0.58, r: 45, hit: 0 }]; } 
        else if (currentMap === 5) { cannibalPlants = [{ x: GAME_WIDTH * 0.15, y: GAME_HEIGHT * 0.5, r: 65, eatTimer: 0, cooldown: 0 }, { x: GAME_WIDTH * 0.85, y: GAME_HEIGHT * 0.5, r: 65, eatTimer: 0, cooldown: 0 }]; }

        const overlay = document.getElementById('round-overlay');
        if (overlay) overlay.classList.remove('hidden');
        document.getElementById('mpi-p1').classList.remove('d-none');
        document.getElementById('mpi-p2').classList.remove('d-none');
        const cdTexts = document.querySelectorAll('.countdown-text');
        cdTexts.forEach(el => { el.classList.remove('d-none'); el.innerText = '3'; el.style.transform = 'translate(-50%, -50%) scale(1)'; });
        
        let count = 3; 
        audio.playTick();
        if (countdownInterval) clearInterval(countdownInterval);
        
        countdownInterval = setInterval(() => {
            count--;
            if (count > 0) { 
                audio.playTick();
                cdTexts.forEach(el => { 
                    el.innerText = count; 
                    el.style.transform = 'translate(-50%, -50%) scale(1.2)'; 
                    setTimeout(() => { el.style.transform = 'translate(-50%, -50%) scale(1)'; }, 150); 
                });
            }
            else if (count === 0) { 
                audio.playStart();
                cdTexts.forEach(el => { el.innerText = "START!"; el.style.transform = 'translate(-50%, -50%) scale(1.3)'; });
            }
            else { 
                clearInterval(countdownInterval); 
                if (overlay) overlay.classList.add('hidden');
                document.getElementById('mpi-p1').classList.add('d-none');
                document.getElementById('mpi-p2').classList.add('d-none');
                cdTexts.forEach(el => el.classList.add('d-none'));
                gameState = 'PLAYING'; 
                audio.startBGM();
            }
        }, 1000);
    }
    function initGameMechanics() {
        player1 = new Player(GAME_WIDTH / 2, GAME_HEIGHT * 0.2, selectedChars.p1, true);
        player2 = new Player(GAME_WIDTH / 2, GAME_HEIGHT * 0.8, selectedChars.p2, false);
        ball = new Ball(); 
        startRoundCountdown();
    }
    window.triggerGoal = function(playerNum) {
        if (gameState !== 'PLAYING') return;
        gameState = 'GOAL'; shakeAmount = 25; 
        audio.stopBGM();
        audio.playGoal();

        if (playerNum === 1) scores.p1++; else scores.p2++;
        updateScoreDisplay();

        const msgs = document.querySelectorAll('.goal-message');
        if (scores.p1 >= WINNING_SCORE || scores.p2 >= WINNING_SCORE) {
            gameState = 'GAMEOVER'; 
            msgs.forEach(el => { el.innerText = playerNum === 1 ? "ç´…æ–¹ç²å‹ï¼" : "è—æ–¹ç²å‹ï¼"; el.style.color = "#FFEB3B"; el.classList.add('show-goal'); });
            for(let i=0; i<15; i++) createConfettiAt(GAME_WIDTH/2, GAME_HEIGHT/2, `hsl(${Math.random()*360}, 80%, 60%)`);
            setTimeout(() => { if (gameState !== 'GAMEOVER') return; msgs.forEach(el => el.classList.remove('show-goal')); window.returnToLobby(); }, 4000);
            return;
        }

        msgs.forEach(el => { el.innerText = playerNum === 1 ? "ç´…æ–¹å¾—åˆ†ï¼" : "è—æ–¹å¾—åˆ†ï¼"; el.style.color = playerNum === 1 ? "#ff5252" : "#4dd0e1"; el.classList.add('show-goal'); });
        setTimeout(() => { if (gameState !== 'GOAL') return; msgs.forEach(el => el.classList.remove('show-goal')); startRoundCountdown(); }, 2500);
    }

    // ==========================================
    // 4. ç¹ªåœ–æ ¸å¿ƒå‡½æ•¸
    // ==========================================
    function drawBeautifulBackground() {
        if (!bgCtx) return;
        const stripeH = GAME_HEIGHT / 14;
        let colorA, colorB, goal1, goal2;
        if (currentMap === 1) { colorA = '#4CAF50'; colorB = '#388E3C'; goal1 = 'rgba(211, 47, 47, 0.85)'; goal2 = 'rgba(25, 118, 210, 0.85)'; } 
        else if (currentMap === 2) { colorA = '#E0F7FA'; colorB = '#B2EBF2'; goal1 = 'rgba(181, 55, 131, 0.85)'; goal2 = 'rgba(2, 119, 189, 0.85)'; } 
        else if (currentMap === 3) { colorA = '#FFF3E0'; colorB = '#FFE0B2'; goal1 = 'rgba(230, 81, 0, 0.85)'; goal2 = 'rgba(0, 150, 136, 0.85)'; }
        else if (currentMap === 4) { colorA = '#1B5E20'; colorB = '#2E7D32'; goal1 = 'rgba(255, 152, 0, 0.85)'; goal2 = 'rgba(121, 85, 72, 0.85)'; }
        else if (currentMap === 5) { colorA = '#004D40'; colorB = '#00695C'; goal1 = 'rgba(216, 67, 21, 0.85)'; goal2 = 'rgba(173, 20, 87, 0.85)'; }
        else if (currentMap === 6) { colorA = '#263238'; colorB = '#37474F'; goal1 = 'rgba(0, 229, 255, 0.85)'; goal2 = 'rgba(213, 0, 249, 0.85)'; }

        for (let i = 0; i < 15; i++) { bgCtx.fillStyle = i % 2 === 0 ? colorA : colorB; bgCtx.fillRect(0, i * stripeH, GAME_WIDTH, stripeH); }
        
        bgCtx.strokeStyle = currentMap === 2 ? 'rgba(0, 0, 0, 0.15)' : 'rgba(255, 255, 255, 0.8)'; 
        if(currentMap === 4 || currentMap === 5) bgCtx.strokeStyle = 'rgba(139, 195, 74, 0.4)';
        if(currentMap === 6) bgCtx.strokeStyle = 'rgba(0, 229, 255, 0.4)';

        bgCtx.lineWidth = 6; const pad = 20;
        bgCtx.strokeRect(pad, pad, GAME_WIDTH - pad*2, GAME_HEIGHT - pad*2);
        bgCtx.beginPath(); bgCtx.moveTo(pad, GAME_HEIGHT/2); bgCtx.lineTo(GAME_WIDTH-pad, GAME_HEIGHT/2); bgCtx.stroke();
        bgCtx.beginPath(); bgCtx.arc(GAME_WIDTH/2, GAME_HEIGHT/2, 100, 0, Math.PI*2); bgCtx.stroke();
        bgCtx.beginPath(); bgCtx.arc(GAME_WIDTH/2, GAME_HEIGHT/2, 8, 0, Math.PI*2); bgCtx.fillStyle = bgCtx.strokeStyle; bgCtx.fill();

        if (currentMap === 3) {
            bgCtx.save();
            bgCtx.fillStyle = '#795548'; bgCtx.fillRect(0, GAME_HEIGHT/2 - 40, GAME_WIDTH, 80);
            bgCtx.fillStyle = '#4E342E'; for(let i=0; i<GAME_WIDTH; i+=40) { bgCtx.fillRect(i, GAME_HEIGHT/2 - 35, 12, 70); }
            bgCtx.fillStyle = '#B0BEC5'; bgCtx.fillRect(0, GAME_HEIGHT/2 - 25, GAME_WIDTH, 6); bgCtx.fillRect(0, GAME_HEIGHT/2 + 19, GAME_WIDTH, 6);
            bgCtx.restore();
        }

        const penW = GAME_WIDTH * 0.4, goalW = GAME_WIDTH * 0.4;
        bgCtx.strokeRect((GAME_WIDTH-penW)/2, pad, penW, 160); bgCtx.strokeRect((GAME_WIDTH-penW)/2, GAME_HEIGHT-pad-160, penW, 160);
        bgCtx.strokeRect((GAME_WIDTH-goalW)/2, pad, goalW, 60); bgCtx.strokeRect((GAME_WIDTH-goalW)/2, GAME_HEIGHT-pad-60, goalW, 60);

        bgCtx.save(); bgCtx.translate(GAME_WIDTH/2, GAME_HEIGHT/2);
        if (currentMap === 2) {
            bgCtx.strokeStyle = 'rgba(255,255,255,0.7)'; bgCtx.lineWidth = 6; bgCtx.lineCap = 'round';
            for(let i=0; i<6; i++) { bgCtx.save(); bgCtx.rotate(i * Math.PI / 3); bgCtx.beginPath(); bgCtx.moveTo(0,0); bgCtx.lineTo(0, -60); bgCtx.moveTo(0, -30); bgCtx.lineTo(-15, -45); bgCtx.moveTo(0, -30); bgCtx.lineTo(15, -45); bgCtx.stroke(); bgCtx.restore(); }
        } else if (currentMap === 3) {
            bgCtx.fillStyle = 'rgba(255, 152, 0, 0.4)'; bgCtx.fillRect(-35, -5, 25, 75); bgCtx.fillRect(10, -5, 25, 75); bgCtx.fillRect(-25, -45, 50, 40); bgCtx.fillRect(-12, -100, 24, 55); bgCtx.fillRect(-4, -135, 8, 35);  
        } else if (currentMap === 4 || currentMap === 5) {
            bgCtx.fillStyle = 'rgba(51, 105, 30, 0.5)';
            bgCtx.beginPath(); bgCtx.moveTo(0, -70); bgCtx.bezierCurveTo(60, -70, 80, -20, 0, 70); bgCtx.bezierCurveTo(-80, -20, -60, -70, 0, -70); bgCtx.fill();
        } else if (currentMap === 6) {
            bgCtx.strokeStyle = 'rgba(0, 229, 255, 0.2)'; bgCtx.lineWidth = 8;
            for(let i=0; i<3; i++) {
                bgCtx.save(); bgCtx.rotate(i * Math.PI * 2 / 3);
                bgCtx.beginPath(); bgCtx.moveTo(0, 0);
                bgCtx.quadraticCurveTo(30, -70, 0, -140); bgCtx.quadraticCurveTo(-15, -70, 0, 0);
                bgCtx.fillStyle = 'rgba(255, 255, 255, 0.05)'; bgCtx.fill(); bgCtx.stroke(); bgCtx.restore();
            }
        }
        bgCtx.restore();

        bgCtx.fillStyle = goal1; bgCtx.beginPath(); bgCtx.moveTo(0,0); bgCtx.lineTo(GAME_WIDTH, 0); bgCtx.lineTo(GAME_WIDTH, 90);
        for(let i=10; i>0; i--) bgCtx.lineTo(GAME_WIDTH*(i/10), 90 + (i%2===0?25:-10)); bgCtx.lineTo(0, 90); bgCtx.fill();
        bgCtx.fillStyle = '#fff'; bgCtx.beginPath(); bgCtx.arc(GOAL_LEFT, 40, 20, 0, Math.PI*2); bgCtx.fill(); bgCtx.beginPath(); bgCtx.arc(GOAL_RIGHT, 40, 20, 0, Math.PI*2); bgCtx.fill();
        
        bgCtx.fillStyle = goal2; bgCtx.beginPath(); bgCtx.moveTo(0,GAME_HEIGHT); bgCtx.lineTo(GAME_WIDTH, GAME_HEIGHT); bgCtx.lineTo(GAME_WIDTH, GAME_HEIGHT-90);
        for(let i=10; i>0; i--) bgCtx.lineTo(GAME_WIDTH*(i/10), GAME_HEIGHT-90 - (i%2===0?25:-10)); bgCtx.lineTo(0, GAME_HEIGHT-90); bgCtx.fill();
        bgCtx.fillStyle = '#fff'; bgCtx.beginPath(); bgCtx.arc(GOAL_LEFT, GAME_HEIGHT-40, 20, 0, Math.PI*2); bgCtx.fill(); bgCtx.beginPath(); bgCtx.arc(GOAL_RIGHT, GAME_HEIGHT-40, 20, 0, Math.PI*2); bgCtx.fill();
    }

    function renderLobbyPreviews() {
        for(let i=1; i<=6; i++) {
            ['p1','p2'].forEach(p => {
                const c = document.getElementById(`pre-${p}-${i}`);
                if(c){ 
                    c.width=120; c.height=120; 
                    let pCtx = c.getContext('2d');
                    pCtx.clearRect(0,0,120,120);
                    let previewAngle = (p === 'p1') ? Math.PI : 0;
                    drawVectorChar(pCtx, i, 60, 60, i===4?48:50, false, {}, null, null, previewAngle); 
                }
            });
        }
    }

    function drawCannibalPlant(ctx, plant) {
        ctx.save(); ctx.translate(plant.x, plant.y);
        ctx.fillStyle = '#1B5E20';
        for(let i=0; i<4; i++) { ctx.save(); ctx.rotate(i * Math.PI/2 + Math.PI/4); ctx.beginPath(); ctx.ellipse(0, plant.r*1.1, plant.r*0.4, plant.r*0.8, 0, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
        if (plant.eatTimer > 0) {
            let scaleX = 1 + Math.sin(plant.eatTimer * 0.4) * 0.15, scaleY = 1 - Math.sin(plant.eatTimer * 0.4) * 0.15; ctx.scale(scaleX, scaleY);
            ctx.fillStyle = '#2E7D32'; ctx.beginPath(); ctx.arc(0, 0, plant.r, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#B71C1C'; ctx.lineWidth = 4; 
            let limit = Math.floor(plant.r * 0.9); ctx.beginPath(); ctx.moveTo(-limit, 0); 
            for(let i = -limit; i <= limit; i += 10) { ctx.lineTo(i, (Math.abs(i) % 20 === 0) ? 6 : -6); } ctx.stroke();
        } else {
            ctx.fillStyle = '#2E7D32'; ctx.beginPath(); ctx.arc(0, 0, plant.r, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#B71C1C'; ctx.beginPath(); ctx.ellipse(0, 0, plant.r*0.85, plant.r*0.85, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#4A148C'; ctx.beginPath(); ctx.ellipse(0, 0, plant.r*0.4, plant.r*0.4, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#FFF'; let teethCount = 14;
            for(let i=0; i<teethCount; i++) {
                let ang = i * (Math.PI * 2 / teethCount); ctx.save(); ctx.rotate(ang); ctx.beginPath(); ctx.moveTo(plant.r*0.85, -10); ctx.lineTo(plant.r*0.5, 0); ctx.lineTo(plant.r*0.85, 10); ctx.fill(); ctx.restore();
            }
        }
        ctx.restore();
    }

    function drawMushroom(ctx, mush) {
        ctx.save(); ctx.translate(mush.x, mush.y);
        if (mush.hit > 0) { let scaleX = 1 + Math.sin(mush.hit * 0.5) * 0.3; let scaleY = 1 - Math.sin(mush.hit * 0.5) * 0.2; ctx.scale(scaleX, scaleY); mush.hit--; }
        let r = mush.r; ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.beginPath(); ctx.ellipse(0, r*0.4, r*0.9, r*0.3, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#FFF9C4'; ctx.beginPath(); ctx.moveTo(-r*0.3, 0); ctx.lineTo(r*0.3, 0); ctx.lineTo(r*0.4, r*0.5); ctx.lineTo(-r*0.4, r*0.5); ctx.fill();
        ctx.fillStyle = '#9C27B0'; ctx.beginPath(); ctx.arc(0, 0, r, Math.PI, 0); ctx.quadraticCurveTo(r, r*0.3, 0, r*0.3); ctx.quadraticCurveTo(-r, r*0.3, -r, 0); ctx.fill();
        ctx.fillStyle = '#76FF03'; ctx.beginPath(); ctx.arc(-r*0.4, -r*0.4, r*0.2, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(r*0.5, -r*0.3, r*0.15, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(0, -r*0.7, r*0.18, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    }

    function drawLightRailTrain(ctx, x) {
        ctx.save(); ctx.translate(x, GAME_HEIGHT / 2);
        ctx.fillStyle = '#FAFAFA'; ctx.beginPath(); ctx.moveTo(0, -35); ctx.lineTo(770, -35); ctx.quadraticCurveTo(800, -35, 800, -10); ctx.lineTo(800, 35); ctx.lineTo(0, 35); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#64DD17'; ctx.fillRect(0, 5, 800, 15); ctx.fillStyle = '#263238'; for(let w=20; w<780; w+=65) { ctx.fillRect(w, -20, 45, 20); }
        ctx.fillStyle = '#455A64'; ctx.fillRect(160, -25, 30, 60); ctx.fillRect(560, -25, 30, 60); 
        ctx.fillStyle = '#9E9E9E'; ctx.fillRect(50, -45, 100, 10); ctx.fillRect(250, -45, 80, 10); ctx.fillRect(450, -45, 100, 10); ctx.fillRect(650, -45, 80, 10);
        ctx.restore();
    }

    function drawItem(ctx, item) {
        ctx.save(); ctx.translate(item.x, item.y + item.floatY);
        const colors = { 1: '#FF5252', 2: '#8D6E63', 3: '#FFEB3B', 4: '#03A9F4', 5: '#E040FB', 6: '#3E2723' };
        const mainColor = colors[item.type];
        ctx.save(); ctx.rotate(item.tick * 0.03); ctx.beginPath(); ctx.arc(0, 0, item.radius, 0, Math.PI * 2); ctx.strokeStyle = mainColor; ctx.lineWidth = 4; ctx.globalAlpha = 0.8; ctx.setLineDash([12, 10]); ctx.stroke(); ctx.restore();
        if (item.type === 5) { ctx.fillStyle = 'rgba(255, 255, 255, 0.75)'; ctx.beginPath(); ctx.arc(0, 0, item.radius * 0.6, 0, Math.PI * 2); ctx.fill(); } else { ctx.fillStyle = mainColor; ctx.globalAlpha = 0.2; ctx.beginPath(); ctx.arc(0, 0, item.radius, 0, Math.PI * 2); ctx.fill(); }
        ctx.globalAlpha = 1.0; ctx.scale(1.8, 1.8);
        if (item.type === 1) { ctx.fillStyle = '#E53935'; ctx.beginPath(); ctx.ellipse(0, 2, 10, 18, 0.3, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#4CAF50'; ctx.beginPath(); ctx.arc(0, -12, 6, 0, Math.PI); ctx.fill(); ctx.strokeStyle = '#4CAF50'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, -12); ctx.lineTo(-2, -18); ctx.stroke(); } 
        else if (item.type === 2) { ctx.fillStyle = '#FFF3E0'; ctx.beginPath(); ctx.moveTo(-11, -12); ctx.lineTo(11, -12); ctx.lineTo(8, 16); ctx.lineTo(-8, 16); ctx.fill(); ctx.fillStyle = '#A1887F'; ctx.beginPath(); ctx.moveTo(-9, -2); ctx.lineTo(9, -2); ctx.lineTo(7, 14); ctx.lineTo(-7, 14); ctx.fill(); ctx.fillStyle = '#111'; ctx.beginPath(); ctx.arc(-4, 10, 2.5, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(3, 11, 2.5, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(4, 5, 2.5, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(-2, 4, 2.5, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#D32F2F'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(3, -2); ctx.lineTo(6, -22); ctx.stroke(); } 
        else if (item.type === 3) { ctx.fillStyle = '#FFF'; ctx.fillRect(-12, -5, 24, 20); ctx.fillStyle = '#E53935'; ctx.fillRect(-8, -5, 4, 20); ctx.fillRect(4, -5, 4, 20); ctx.fillStyle = '#FFEB3B'; ctx.beginPath(); ctx.arc(-8, -8, 8, 0, Math.PI*2); ctx.arc(0, -12, 10, 0, Math.PI*2); ctx.arc(8, -8, 8, 0, Math.PI*2); ctx.fill(); } 
        else if (item.type === 4) { ctx.fillStyle = '#03A9F4'; ctx.beginPath(); ctx.arc(0, 10, 15, 0, Math.PI); ctx.fill(); ctx.fillStyle = '#E0F7FA'; ctx.beginPath(); ctx.moveTo(-15, 10); ctx.lineTo(15, 10); ctx.lineTo(0, -15); ctx.fill(); ctx.fillStyle = '#FFCA28'; ctx.fillRect(-5, -5, 5, 5); ctx.fillRect(2, 2, 6, 6); ctx.fillRect(-8, 5, 5, 5); } 
        else if (item.type === 5) { ctx.fillStyle = '#4CAF50'; ctx.beginPath(); ctx.ellipse(-6, 5, 6, 12, -0.2, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(6, 5, 6, 12, 0.2, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(0, 6, 8, 14, 0, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#1B5E20'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, -8); ctx.lineTo(0, -14); ctx.stroke(); } 
        else if (item.type === 6) { ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.beginPath(); ctx.moveTo(-10,-10); ctx.lineTo(10,-10); ctx.lineTo(7,15); ctx.lineTo(-7,15); ctx.fill(); ctx.fillStyle = '#3E2723'; ctx.beginPath(); ctx.moveTo(-9,-5); ctx.lineTo(9,-5); ctx.lineTo(6,13); ctx.lineTo(-6,13); ctx.fill(); ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.fillRect(-5, -2, 6, 6); ctx.fillRect(2, 4, 5, 5); ctx.strokeStyle = '#111'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(0,-10); ctx.lineTo(5,-20); ctx.stroke(); }
        ctx.restore();
    }

    function drawPopcornWall(ctx, isTop) {
        let y = isTop ? 180 : GAME_HEIGHT - 180; let goalW = GAME_WIDTH * 0.45; let startX = (GAME_WIDTH - goalW) / 2; let endX = (GAME_WIDTH + goalW) / 2;
        ctx.save(); ctx.fillStyle = '#FFF'; ctx.fillRect(startX, isTop ? y-20 : y, goalW, 20); ctx.fillStyle = '#E53935';
        for (let x = startX+10; x <= endX; x += 40) { ctx.fillRect(x, isTop ? y-20 : y, 20, 20); } ctx.fillStyle = '#FFEB3B'; ctx.strokeStyle = '#FBC02D'; ctx.lineWidth=2;
        for (let x = startX; x <= endX; x += 30) { ctx.beginPath(); ctx.arc(x, y - (isTop?20:-20), 20, 0, Math.PI*2); ctx.fill(); ctx.stroke(); } ctx.restore();
    }

    function drawVectorBall(ctx, x, y, radius, rotation, homingTimer, fireTimer, protectionTimer) {
        ctx.save(); ctx.translate(x, y); 
        if (protectionTimer > 0) {
            ctx.strokeStyle = '#4fc3f7'; ctx.lineWidth = 4; ctx.setLineDash([10, 10]);
            ctx.beginPath(); ctx.arc(0, 0, radius + 40, 0, Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
            ctx.fillStyle = 'rgba(79, 195, 247, 0.2)'; ctx.fill();
        }
        if (homingTimer > 0) {
            ctx.strokeStyle = 'rgba(255, 50, 50, 0.8)'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(0, 0, radius + 15, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-radius-25, 0); ctx.lineTo(-radius-5, 0); ctx.moveTo(radius+5, 0); ctx.lineTo(radius+25, 0); ctx.moveTo(0, -radius-25); ctx.lineTo(0, -radius-5); ctx.moveTo(0, radius+5); ctx.lineTo(0, radius+25); ctx.stroke(); ctx.fillStyle = 'rgba(255, 50, 50, 0.3)'; ctx.beginPath(); ctx.arc(0, 0, radius + 15, 0, Math.PI*2); ctx.fill();
        }
        ctx.rotate(rotation);
        if (fireTimer > 0) { ctx.fillStyle = '#FF5722'; ctx.beginPath(); ctx.arc(0, 0, radius + Math.random()*10, 0, Math.PI*2); ctx.fill(); }

        ctx.fillStyle = '#f0ebd8'; ctx.beginPath(); ctx.arc(0, 0, radius, 0, Math.PI*2); ctx.fill(); ctx.lineWidth = 2; ctx.strokeStyle = '#333'; ctx.stroke();
        ctx.fillStyle = '#2c3e50'; ctx.beginPath(); for (let i=0; i<5; i++) { let angle = (i*Math.PI*2)/5 - Math.PI/2; ctx.lineTo(Math.cos(angle)*radius*0.4, Math.sin(angle)*radius*0.4); } ctx.fill();
        ctx.strokeStyle = '#2c3e50'; ctx.lineWidth = 3; for (let i=0; i<5; i++) { let angle = (i*Math.PI*2)/5 - Math.PI/2; ctx.beginPath(); ctx.moveTo(Math.cos(angle)*radius*0.4, Math.sin(angle)*radius*0.4); ctx.lineTo(Math.cos(angle)*radius, Math.sin(angle)*radius); ctx.stroke(); }
        ctx.fillStyle = 'rgba(121, 85, 72, 0.6)'; ctx.beginPath(); ctx.arc(radius*0.4, radius*0.3, radius*0.2, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(-radius*0.5, radius*0.2, radius*0.3, 0, Math.PI*2); ctx.fill(); ctx.restore();
    }

    function drawVectorChar(ctx, type, x, y, radius, isActive, states = {}, kickAnim = null, hitAnim = null, facingAngle = 0) {
        ctx.save(); 
        ctx.translate(x, y);

        if (kickAnim && kickAnim.timer > 0) {
            let progress = kickAnim.timer / 15; 
            let stretch = Math.sin(progress * Math.PI) * 0.4; 
            ctx.rotate(kickAnim.angle);
            ctx.scale(1 + stretch, 1 - stretch * 0.5);
            ctx.rotate(-kickAnim.angle);
        }

        if (hitAnim && hitAnim.timer > 0) {
            let progress = hitAnim.timer / 15; 
            let squash = Math.sin(progress * Math.PI) * 0.3; 
            ctx.rotate(hitAnim.angle);
            ctx.scale(1 - squash, 1 + squash * 0.5); 
            ctx.rotate(-hitAnim.angle);
        }

        ctx.rotate(facingAngle);

        if (isActive && gameState === 'PLAYING') {
            if (type === 5) { ctx.beginPath(); ctx.arc(0, 0, 160, 0, Math.PI*2); ctx.fillStyle = 'rgba(236, 64, 122, 0.1)'; ctx.fill(); ctx.strokeStyle = 'rgba(236, 64, 122, 0.4)'; ctx.lineWidth = 2; ctx.setLineDash([15, 15]); ctx.stroke(); ctx.setLineDash([]); }
            ctx.beginPath(); ctx.arc(0, 0, radius + 15, 0, Math.PI*2); ctx.strokeStyle = "rgba(255, 255, 255, 0.6)"; ctx.lineWidth = 4; ctx.setLineDash([15, 10]); ctx.stroke(); ctx.setLineDash([]);
        }
        if (type === 1) { 
            ctx.fillStyle = '#E53935'; ctx.beginPath(); ctx.arc(0, 0, radius, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#C62828'; for(let i=0; i<20; i++){ let ang = (i*Math.PI*2)/20; ctx.beginPath(); ctx.arc(Math.cos(ang)*radius*0.95, Math.sin(ang)*radius*0.95, 8, 0, Math.PI*2); ctx.fill(); } ctx.fillStyle = '#E53935'; ctx.beginPath(); ctx.arc(0, 0, radius*0.95, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#FFF'; ctx.beginPath(); ctx.ellipse(-radius*0.6, -radius*0.3, 12, 25, -Math.PI/6, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(radius*0.6, -radius*0.3, 12, 25, Math.PI/6, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#3E2723'; ctx.lineWidth = 4; ctx.lineCap = 'round'; ctx.beginPath(); ctx.arc(-18, -10, 8, 0, Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(18, -10, 8, 0, Math.PI); ctx.stroke(); ctx.fillStyle = 'rgba(255, 182, 193, 0.7)'; ctx.beginPath(); ctx.arc(-30, 5, 10, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(30, 5, 10, 0, Math.PI*2); ctx.fill();
        } else if (type === 2) { 
            ctx.fillStyle = '#26A69A'; ctx.beginPath(); ctx.arc(0, 0, radius, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#FFF3E0'; ctx.beginPath(); ctx.arc(0, 0, radius, Math.PI, Math.PI*2); ctx.fill(); ctx.fillStyle = '#00897B'; for(let i=0; i<10; i++){ let ang = (i*Math.PI)/10; ctx.beginPath(); ctx.arc(Math.cos(ang)*radius*0.95, Math.sin(ang)*radius*0.95, 8, 0, Math.PI*2); ctx.fill(); }
            ctx.fillStyle = '#5D4037'; ctx.beginPath(); ctx.arc(0, -radius*0.4, 25, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(-20, -radius*0.2, 15, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(20, -radius*0.2, 15, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#111'; ctx.beginPath(); ctx.arc(-10, -radius*0.4, 4, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(10, -radius*0.4, 4, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = 'rgba(255, 138, 128, 0.6)'; ctx.beginPath(); ctx.arc(-35, -5, 12, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(35, -5, 12, 0, Math.PI*2); ctx.fill();
        } else if (type === 3) {
            ctx.fillStyle = '#FDD835'; ctx.beginPath(); ctx.arc(0, 0, radius, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#FBC02D'; for(let i=0; i<20; i++){ let ang = (i*Math.PI*2)/20; ctx.beginPath(); ctx.arc(Math.cos(ang)*radius*0.95, Math.sin(ang)*radius*0.95, 8, 0, Math.PI*2); ctx.fill(); } ctx.fillStyle = '#FDD835'; ctx.beginPath(); ctx.arc(0, 0, radius*0.95, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#FFF'; ctx.beginPath(); ctx.ellipse(-radius*0.65, -radius*0.35, 15, 25, -Math.PI/4, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(radius*0.65, -radius*0.35, 15, 25, Math.PI/4, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#222'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(-radius, -radius*0.2); ctx.lineTo(radius, radius*0.1); ctx.stroke(); ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(-18, -6, 14, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#3E2723'; ctx.lineWidth = 4; ctx.lineCap = 'round'; ctx.beginPath(); ctx.arc(20, -5, 8, 0, Math.PI); ctx.stroke(); ctx.fillStyle = 'rgba(255, 150, 150, 0.6)'; ctx.beginPath(); ctx.arc(-35, 5, 10, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(35, 5, 10, 0, Math.PI*2); ctx.fill();
        } else if (type === 4) {
            ctx.fillStyle = '#8BC34A'; for(let i=0; i<16; i++){ let ang = (i*Math.PI*2)/16; ctx.beginPath(); ctx.arc(Math.cos(ang)*radius*0.9, Math.sin(ang)*radius*0.9, radius*0.2, 0, Math.PI*2); ctx.fill(); } ctx.fillStyle = '#E53935'; for(let i=0; i<4; i++){ let ang = (i*Math.PI*2)/4 + Math.PI/4; ctx.beginPath(); ctx.arc(Math.cos(ang)*radius*0.85, Math.sin(ang)*radius*0.85, radius*0.25, 0, Math.PI*2); ctx.fill(); } ctx.fillStyle = '#F5B041'; ctx.beginPath(); ctx.arc(0, 0, radius*0.85, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#FFF8E1'; const seeds = [[-0.4,-0.5,0.5], [0.4,-0.6,-0.3], [0,-0.7,0], [-0.5,0,1], [0.5,0.2,-0.8], [0,-0.3,0.2], [-0.3,0.5,-0.5], [0.3,0.6,0.6]]; seeds.forEach(s => { ctx.save(); ctx.translate(s[0]*radius, s[1]*radius); ctx.rotate(s[2]); ctx.beginPath(); ctx.ellipse(0, 0, radius*0.04, radius*0.08, 0, 0, Math.PI*2); ctx.fill(); ctx.restore(); });
            ctx.strokeStyle = '#5D4037'; ctx.lineWidth = radius * 0.08; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.beginPath(); ctx.moveTo(-radius*0.35, -radius*0.05); ctx.lineTo(-radius*0.15, -radius*0.2); ctx.lineTo(0, -radius*0.05); ctx.lineTo(radius*0.15, -radius*0.2); ctx.lineTo(radius*0.35, -radius*0.05); ctx.stroke();
        } else if (type === 5) {
            ctx.fillStyle = '#FFE082'; ctx.beginPath(); ctx.arc(0, 0, radius, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#FFCA28'; for(let i=0; i<20; i++){ let ang = (i*Math.PI*2)/20; ctx.beginPath(); ctx.arc(Math.cos(ang)*radius*0.95, Math.sin(ang)*radius*0.95, 8, 0, Math.PI*2); ctx.fill(); } ctx.fillStyle = '#FFE082'; ctx.beginPath(); ctx.arc(0, 0, radius*0.95, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#EC407A'; ctx.beginPath(); ctx.ellipse(-15, -radius*0.75, 14, 10, -Math.PI/6, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(15, -radius*0.75, 14, 10, Math.PI/6, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#D81B60'; ctx.beginPath(); ctx.arc(0, -radius*0.75, 8, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#5D4037'; ctx.lineWidth = 4; ctx.lineCap = 'round'; ctx.beginPath(); ctx.arc(-18, -5, 7, 0, Math.PI); ctx.stroke(); ctx.beginPath(); ctx.arc(18, -5, 7, 0, Math.PI); ctx.stroke(); ctx.fillStyle = 'rgba(244, 143, 177, 0.7)'; ctx.beginPath(); ctx.arc(-32, 8, 10, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(32, 8, 10, 0, Math.PI*2); ctx.fill();
        } else if (type === 6) {
            ctx.fillStyle = '#212121'; ctx.beginPath(); ctx.arc(0, 0, radius, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#424242'; for(let i=0; i<20; i++){ let ang = (i*Math.PI*2)/20; ctx.beginPath(); ctx.arc(Math.cos(ang)*radius*0.95, Math.sin(ang)*radius*0.95, 8, 0, Math.PI*2); ctx.fill(); }
            ctx.fillStyle = '#212121'; ctx.beginPath(); ctx.arc(0, 0, radius*0.95, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#FFF'; ctx.beginPath(); ctx.moveTo(-15, radius*0.7); ctx.lineTo(0, radius*0.4); ctx.lineTo(15, radius*0.7); ctx.fill();
            ctx.strokeStyle = '#FFC107'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(-12, -5, 10, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.arc(12, -5, 10, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-2, -5); ctx.lineTo(2, -5); ctx.stroke();
        }

        if(type !== 4 && type !== 6) { 
            ctx.fillStyle = '#F48FB1'; ctx.beginPath(); ctx.ellipse(0, 15, 22, 15, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#880E4F'; ctx.beginPath(); ctx.ellipse(-8, 15, 4, 6, -0.2, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(8, 15, 4, 6, 0.2, 0, Math.PI*2); ctx.fill();
        } else if (type === 6) {
            ctx.fillStyle = '#F48FB1'; ctx.beginPath(); ctx.ellipse(0, 10, 15, 10, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#880E4F'; ctx.beginPath(); ctx.ellipse(-5, 10, 3, 4, -0.2, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(5, 10, 3, 4, 0.2, 0, Math.PI*2); ctx.fill();
        }

        if (states.freeze) { ctx.fillStyle = 'rgba(135, 206, 235, 0.6)'; ctx.fillRect(-radius, -radius, radius*2, radius*2); ctx.strokeStyle = '#FFF'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-radius*0.8, -radius*0.5); ctx.lineTo(-radius*0.5, -radius*0.8); ctx.stroke(); }
        if (states.confuse) { ctx.strokeStyle = '#E040FB'; ctx.lineWidth = 4; for(let i=0; i<3; i++) { ctx.beginPath(); ctx.arc((i-1)*25, -radius-15, 12, 0, Math.PI*1.5); ctx.stroke(); } }
        if (states.coffee) { ctx.strokeStyle = '#FF1744'; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(0, 0, radius+10, 0, Math.PI*2); ctx.stroke(); ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; ctx.beginPath(); ctx.arc(-18, -5, 12, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(18, -5, 12, 0, Math.PI*2); ctx.fill(); }
        ctx.restore();
    }

    class Ball {
        constructor() { this.radius = 35; this.reset(); }
        reset() { 
            this.x = GAME_WIDTH/2; this.y = GAME_HEIGHT/2; 
            this.vx = 0; this.vy = 0; this.rotation = 0; 
            this.homingTimer = 0; this.homingPlayer = null; this.fireTimer = 0;
            this.isEaten = false; this.protectionTimer = 0; this.protectedBy = null;
        }
        update() {
            if (this.isEaten) return; 

            let friction = currentMap === 2 ? 0.992 : 0.960; 
            this.vx *= friction; this.vy *= friction;
            
            if (currentMap === 2 && mapState.windActive > 0) { this.vx += mapState.windDir * 0.5; }

            if (currentMap === 6 && mapState.vortexActive > 0) {
                let cx = GAME_WIDTH / 2; let cy = GAME_HEIGHT / 2;
                let dx = this.x - cx; let dy = this.y - cy;
                let dist = Math.hypot(dx, dy);
                let maxDist = 350; 
                if (dist < maxDist && dist > 10) { 
                    let angle = Math.atan2(dy, dx);
                    let force = (1 - dist / maxDist) * 2.0; 
                    this.vx += Math.cos(angle + Math.PI / 2) * force * 1.5;
                    this.vy += Math.sin(angle + Math.PI / 2) * force * 1.5;
                    this.vx -= Math.cos(angle) * force * 0.8;
                    this.vy -= Math.sin(angle) * force * 0.8;
                }
            }

            if (this.protectionTimer > 0) this.protectionTimer--;
            if (this.fireTimer > 0) this.fireTimer--;
            if (this.homingTimer > 0 && this.homingPlayer) {
                this.homingTimer--;
                let targetX = GAME_WIDTH / 2, targetY = this.homingPlayer === 1 ? GAME_HEIGHT : 0;
                let dx = targetX - this.x, dy = targetY - this.y;
                let targetAngle = Math.atan2(dy, dx), currentAngle = Math.atan2(this.vy, this.vx);
                let angleDiff = targetAngle - currentAngle;
                while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2; while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                let newAngle = currentAngle + angleDiff * 0.055;
                let speed = Math.hypot(this.vx, this.vy);
                this.vx = Math.cos(newAngle) * speed; this.vy = Math.sin(newAngle) * speed;
            }

            const speed = Math.hypot(this.vx, this.vy);
            let maxSpeed = this.fireTimer > 0 ? 120 : 60; 
            if (speed > maxSpeed) { this.vx = (this.vx/speed)*maxSpeed; this.vy = (this.vy/speed)*maxSpeed; }
            
            let prevX = this.x, prevY = this.y;
            this.x += this.vx; this.y += this.vy;
            this.rotation += speed * 0.05 * (this.vx > 0 ? 1 : -1);

            if (this.x - this.radius < 0) { 
                this.x = this.radius; this.vx *= -0.8; 
                if(Math.abs(this.vx) > 2) audio.playBounce();
            }
            else if (this.x + this.radius > GAME_WIDTH) { 
                this.x = GAME_WIDTH - this.radius; this.vx *= -0.8; 
                if(Math.abs(this.vx) > 2) audio.playBounce();
            }

            const POST_RADIUS = 20;
            const posts = [
                { x: GOAL_LEFT, y: 40, r: POST_RADIUS },
                { x: GOAL_RIGHT, y: 40, r: POST_RADIUS },
                { x: GOAL_LEFT, y: GAME_HEIGHT - 40, r: POST_RADIUS },
                { x: GOAL_RIGHT, y: GAME_HEIGHT - 40, r: POST_RADIUS }
            ];

            for (let post of posts) {
                let dx = this.x - post.x;
                let dy = this.y - post.y;
                let dist = Math.hypot(dx, dy);
                let minDist = this.radius + post.r;

                if (dist < minDist) {
                    if (dist === 0) { dx = 1; dy = 0; dist = 1; }
                    let overlap = minDist - dist;
                    let nx = dx / dist;
                    let ny = dy / dist;

                    this.x += nx * overlap;
                    this.y += ny * overlap;

                    let v_dot = this.vx * nx + this.vy * ny;
                    if (v_dot < 0) {
                        let restitution = 0.7; 
                        let impulse = -(1 + restitution) * v_dot;
                        this.vx += impulse * nx;
                        this.vy += impulse * ny;
                        
                        shakeAmount = Math.max(shakeAmount, 8); 
                        createConfettiAt(post.x, post.y, '#FFF');
                        audio.playPostHit();
                    }
                }
            }

            if (popcornWalls.p1 > 0 && this.x > GAME_WIDTH*0.25 && this.x < GAME_WIDTH*0.75) {
                if (prevY >= 210 && this.y - this.radius <= 210 && this.vy < 0) { this.y = 210 + this.radius; this.vy *= -1; shakeAmount=10; audio.playBounce(); }
            }
            if (popcornWalls.p2 > 0 && this.x > GAME_WIDTH*0.25 && this.x < GAME_WIDTH*0.75) {
                if (prevY <= GAME_HEIGHT - 210 && this.y + this.radius >= GAME_HEIGHT - 210 && this.vy > 0) { this.y = GAME_HEIGHT - 210 - this.radius; this.vy *= -1; shakeAmount=10; audio.playBounce(); }
            }

            if (currentMap === 3 && mapState.lrtActive > 0) {
                let trainTop = GAME_HEIGHT / 2 - 35, trainBottom = GAME_HEIGHT / 2 + 35, trainLeft = mapState.lrtX, trainRight = mapState.lrtX + 800;
                let minX = Math.min(this.x, prevX) - this.radius, maxX = Math.max(this.x, prevX) + this.radius;
                if (maxX > trainLeft && minX < trainRight) {
                    if (prevY <= trainTop && this.y + this.radius >= trainTop && this.vy > 0) { this.y = trainTop - this.radius; this.vy *= -1.5; shakeAmount = 15; createConfettiAt(this.x, this.y, '#B0BEC5'); audio.playPostHit(); }
                    else if (prevY >= trainBottom && this.y - this.radius <= trainBottom && this.vy < 0) { this.y = trainBottom + this.radius; this.vy *= -1.5; shakeAmount = 15; createConfettiAt(this.x, this.y, '#B0BEC5'); audio.playPostHit(); }
                    else if (this.y + this.radius > trainTop && this.y - this.radius < trainBottom) {
                        if (this.x < trainRight && this.x > trainRight - 60) { this.x = trainRight + this.radius; this.vx = 9 * 2.5; shakeAmount = 15; createConfettiAt(this.x, this.y, '#B0BEC5'); audio.playPostHit(); } 
                        else if (this.x > trainLeft && this.x < trainRight) { if (this.y < GAME_HEIGHT / 2) { this.y = trainTop - this.radius; this.vy = -Math.abs(this.vy); } else { this.y = trainBottom + this.radius; this.vy = Math.abs(this.vy); } }
                    }
                }
            }

            if (this.y - this.radius < 0) {
                if (this.x > GOAL_LEFT && this.x < GOAL_RIGHT) {
                    if (window.triggerGoal) window.triggerGoal(2);
                } else { this.y = this.radius; this.vy *= -0.8; if(Math.abs(this.vy) > 2) audio.playBounce(); }
            } else if (this.y + this.radius > GAME_HEIGHT) {
                if (this.x > GOAL_LEFT && this.x < GOAL_RIGHT) {
                    if (window.triggerGoal) window.triggerGoal(1);
                } else { this.y = GAME_HEIGHT - this.radius; this.vy *= -0.8; if(Math.abs(this.vy) > 2) audio.playBounce(); }
            }
        }
        draw(ctx) { if(!this.isEaten) drawVectorBall(ctx, this.x, this.y, this.radius, this.rotation, this.homingTimer, this.fireTimer, this.protectionTimer); }
    }

    class Player {
        constructor(x, y, type, isTopHalf) {
            this.startX = x; this.startY = y; this.x = x; this.y = y; this.type = type; this.isTopHalf = isTopHalf; 
            
            if (type === 1) { this.baseRadius = 55; this.baseSpeed = 5.0; this.kickPower = 30; } 
            else if (type === 2) { this.baseRadius = 55; this.baseSpeed = 2.2; this.kickPower = 48; } 
            else if (type === 3) { this.baseRadius = 55; this.baseSpeed = 3.5; this.kickPower = 36; } 
            else if (type === 4) { this.baseRadius = 85; this.baseSpeed = 1.5; this.kickPower = 18; }  
            else if (type === 5) { this.baseRadius = 55; this.baseSpeed = 4.0; this.kickPower = 32; } 
            else if (type === 6) { this.baseRadius = 55; this.baseSpeed = 3.5; this.kickPower = 30; } 
            
            this.currentRadius = this.baseRadius; this.isActive = false; this.touchId = null;
            this.speedBuffTimer = 0; this.giantBuffTimer = 0; this.freezeTimer = 0; this.confuseTimer = 0; this.coffeeTimer = 0;
            
            this.kickAnimTimer = 0;
            this.kickAngle = 0;
            this.hitAnimTimer = 0;
            this.hitAngle = 0;

            this.joystick = { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0, vecX: 0, vecY: 0 };
            this.recoilX = 0;
            this.recoilY = 0;
            this.facingAngle = this.isTopHalf ? Math.PI : 0;
        }
        get speed() { return this.speedBuffTimer > 0 ? this.baseSpeed * 1.8 : this.baseSpeed; }
        get kickRange() { return this.currentRadius + 85; }
        
        reset() {
            this.x = this.startX; this.y = this.startY;
            this.isActive = false; this.touchId = null; this.speedBuffTimer = 0; this.giantBuffTimer = 0;
            this.freezeTimer = 0; this.confuseTimer = 0; this.coffeeTimer = 0; this.currentRadius = this.baseRadius;
            this.kickAnimTimer = 0; this.kickAngle = 0;
            this.hitAnimTimer = 0; this.hitAngle = 0;
            this.joystick.active = false;
            this.joystick.vecX = 0; this.joystick.vecY = 0;
            this.recoilX = 0;
            this.recoilY = 0;
            this.facingAngle = this.isTopHalf ? Math.PI : 0; 
        }
        update(ballObj) {
            if (this.speedBuffTimer > 0) this.speedBuffTimer--; if (this.giantBuffTimer > 0) this.giantBuffTimer--;
            if (this.confuseTimer > 0) this.confuseTimer--; if (this.coffeeTimer > 0) this.coffeeTimer--;
            this.currentRadius += ((this.giantBuffTimer > 0 ? this.baseRadius * 1.5 : this.baseRadius) - this.currentRadius) * 0.1;
            
            if (this.kickAnimTimer > 0) this.kickAnimTimer--;
            if (this.hitAnimTimer > 0) this.hitAnimTimer--;

            if (this.freezeTimer > 0) { this.freezeTimer--; this.isActive = false; return; }
            if (!this.isActive) return;

            if (gameState !== 'PLAYING') return;

            let moveSpeed = this.speed;
            let vX = this.joystick.vecX;
            let vY = this.joystick.vecY;

            if (this.confuseTimer > 0) { vX = -vX; vY = -vY; }

            if (Math.hypot(vX, vY) > 0.05) {
                let targetAngle = Math.atan2(vY, vX) + Math.PI / 2; 
                let diff = targetAngle - this.facingAngle;
                while (diff <= -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;
                this.facingAngle += diff * 0.25; 
            }

            if (this.speedBuffTimer > 0 && Math.hypot(vX, vY) > 0.1) {
                particles.push({ x: this.x + (Math.random()-0.5)*this.currentRadius, y: this.y + (Math.random()-0.5)*this.currentRadius, vx: (Math.random()-0.5)*4, vy: (Math.random()-0.5)*4, life: 1.0, color: '#FF5722' });
            }

            if (this.type === 5 && ballObj && !ballObj.isEaten) {
                let dx = this.x - ballObj.x, dy = this.y - ballObj.y, dist = Math.hypot(dx, dy);
                if (dist < 160 && dist > this.currentRadius + ballObj.radius) {
                    let pullForce = 1.0 * (1 - dist / 160); ballObj.vx += (dx / dist) * pullForce; ballObj.vy += (dy / dist) * pullForce;
                }
            }

            this.x += vX * moveSpeed;
            this.y += vY * moveSpeed;

            this.x += this.recoilX;
            this.y += this.recoilY;
            this.recoilX *= 0.6;
            this.recoilY *= 0.6;

            this.x = Math.max(this.currentRadius, Math.min(GAME_WIDTH - this.currentRadius, this.x));
            this.y = Math.max(this.currentRadius, Math.min(GAME_HEIGHT - this.currentRadius, this.y));
        }
        kick(ball) {
            if (this.freezeTimer > 0 || ball.isEaten) return;
            let dx = ball.x - this.x, dy = ball.y - this.y, dist = Math.hypot(dx, dy);
            if (dist < this.kickRange) {
                let actualPower = this.giantBuffTimer > 0 ? this.kickPower * 1.5 : this.kickPower;
                if (this.coffeeTimer > 0) { actualPower *= 2.5; ball.fireTimer = 60; shakeAmount = 25; }
                ball.vx = (dx/(dist||1)) * actualPower; ball.vy = (dy/(dist||1)) * actualPower;
                
                shakeAmount = Math.max(shakeAmount, 12); 
                if(actualPower > 25 && this.coffeeTimer <= 0) shakeAmount = Math.max(shakeAmount, 15);
                shockwaves.push({ x: this.x, y: this.y, r: this.currentRadius, maxR: this.currentRadius + 120, alpha: 0.8 });
                this.kickAnimTimer = 15;
                this.kickAngle = Math.atan2(dy, dx);
                this.facingAngle = this.kickAngle + Math.PI / 2;

                audio.playKick();

                if (this.type === 6) { ball.protectionTimer = 90; ball.protectedBy = this.isTopHalf ? 1 : 2; }
                if (this.type === 3) { ball.homingTimer = 90; ball.homingPlayer = this.isTopHalf ? 1 : 2; } else { ball.homingTimer = 0; ball.homingPlayer = null; }
            }
        }
        draw(ctx) { 
            drawVectorChar(ctx, this.type, this.x, this.y, this.currentRadius, this.isActive, 
                { freeze: this.freezeTimer>0, confuse: this.confuseTimer>0, coffee: this.coffeeTimer>0 },
                { timer: this.kickAnimTimer, angle: this.kickAngle },
                { timer: this.hitAnimTimer, angle: this.hitAngle },
                this.facingAngle
            ); 
        }

        drawJoystick(ctx) {
            if (this.joystick.active && gameState === 'PLAYING') {
                ctx.save();
                const jx = this.joystick.startX;
                const jy = this.joystick.startY;
                const cx = this.joystick.currentX;
                const cy = this.joystick.currentY;

                const color = this.isTopHalf ? 'rgba(255, 82, 82, 0.4)' : 'rgba(77, 208, 225, 0.4)';
                const solidColor = this.isTopHalf ? 'rgba(255, 82, 82, 0.8)' : 'rgba(77, 208, 225, 0.8)';

                ctx.beginPath(); ctx.arc(jx, jy, 60, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; ctx.fill();
                ctx.lineWidth = 4; ctx.strokeStyle = color; ctx.stroke();

                let dx = cx - jx, dy = cy - jy, dist = Math.hypot(dx, dy), maxDist = 60;
                if (dist > maxDist) { dx = (dx / dist) * maxDist; dy = (dy / dist) * maxDist; }

                ctx.beginPath(); ctx.arc(jx + dx, jy + dy, 25, 0, Math.PI * 2);
                ctx.fillStyle = solidColor; ctx.fill();
                ctx.restore();
            }
        }
    }

    // ==========================================
    // 6. éŠæˆ²ç‰©ç†èˆ‡ä¸»è¿´åœˆæ ¸å¿ƒ
    // ==========================================
    function resolveCollisions() {
        if (!ball.isEaten) {
            [player1, player2].forEach(p => {
                if(!p) return;
                let dx = ball.x - p.x, dy = ball.y - p.y; let dist = Math.hypot(dx, dy); let minDist = p.currentRadius + ball.radius;
                
                if (ball.protectionTimer > 0) {
                    let isOwner = (ball.protectedBy === 1 && p.isTopHalf) || (ball.protectedBy === 2 && !p.isTopHalf);
                    if (!isOwner) {
                        let auraDist = minDist + 40;
                        if (dist < auraDist) {
                            let force = (auraDist - dist) * 0.5;
                            p.x -= (dx/(dist||1)) * force; p.y -= (dy/(dist||1)) * force;
                            createConfettiAt(p.x + dx/2, p.y + dy/2, '#4fc3f7');
                            return; 
                        }
                    }
                }

                if (dist < minDist) {
                    if (dist === 0) { dx = 1; dy = 0; dist = 1; }
                    let overlap = minDist - dist;
                    let nx = dx / dist;
                    let ny = dy / dist;

                    ball.x += nx * overlap;
                    ball.y += ny * overlap;

                    let p_vx = p.joystick.vecX * p.speed;
                    let p_vy = p.joystick.vecY * p.speed;

                    let rel_vx = ball.vx - p_vx;
                    let rel_vy = ball.vy - p_vy;
                    let v_dot = rel_vx * nx + rel_vy * ny;

                    if (v_dot < 0) {
                        let restitution = 0.4;
                        let impulse = -(1 + restitution) * v_dot;

                        ball.vx += impulse * nx;
                        ball.vy += impulse * ny;

                        let charWeightFactor = 55 / p.currentRadius; 
                        p.recoilX -= impulse * nx * 1.2 * charWeightFactor;
                        p.recoilY -= impulse * ny * 1.2 * charWeightFactor;

                        if (impulse > 10) {
                            p.hitAnimTimer = 15;
                            p.hitAngle = Math.atan2(dy, dx);
                            audio.playPigHit();
                        }
                    }

                    ball.vx *= 0.85;
                    ball.vy *= 0.85;

                    ball.homingTimer = 0;
                    ball.homingPlayer = null;
                }
            });
            
            if (currentMap === 4 && mushrooms.length > 0) {
                mushrooms.forEach(m => {
                    let dx = ball.x - m.x, dy = ball.y - m.y, dist = Math.hypot(dx, dy);
                    if (dist === 0) { dx = 1; dist = 1; } 
                    let minDist = ball.radius + m.r;
                    if (dist < minDist) {
                        let overlap = minDist - dist; ball.x += (dx/dist) * overlap; ball.y += (dy/dist) * overlap;
                        let nx = dx/dist, ny = dy/dist, vdot = ball.vx * nx + ball.vy * ny;
                        if (vdot < 0) { ball.vx -= 2 * vdot * nx; ball.vy -= 2 * vdot * ny; ball.vx *= 1.4; ball.vy *= 1.4; m.hit = 15; shakeAmount = 15; createConfettiAt(m.x, m.y, '#76FF03'); audio.playBounce(); }
                    }
                });
            }
        }

        if (player1 && player2) {
            let dx = player2.x - player1.x, dy = player2.y - player1.y, dist = Math.hypot(dx, dy), minDist = player1.currentRadius + player2.currentRadius;
            if (dist < minDist) {
                if (dist === 0) { dx = 1; dy = 0; dist = 1; }
                let overlap = minDist - dist, m1 = player1.currentRadius, m2 = player2.currentRadius, totalMass = m1 + m2;
                player1.x -= (dx/dist) * overlap * (m2 / totalMass); player1.y -= (dy/dist) * overlap * (m2 / totalMass);
                player2.x += (dx/dist) * overlap * (m1 / totalMass); player2.y += (dy/dist) * overlap * (m1 / totalMass);
            }
        }

        if (currentMap === 5 && cannibalPlants.length > 0) {
            [player1, player2].forEach(p => {
                if(!p) return;
                cannibalPlants.forEach(plant => {
                    let dx = p.x - plant.x, dy = p.y - plant.y, dist = Math.hypot(dx, dy), minDist = p.currentRadius + plant.r;
                    if (dist < minDist) { 
                        if (dist === 0) { dx = 1; dist = 1; }
                        let overlap = minDist - dist; p.x += (dx/dist) * overlap; p.y += (dy/dist) * overlap; 
                    }
                });
            });
        }

        [player1, player2].forEach(p => {
            if (p) {
                p.x = Math.max(p.currentRadius, Math.min(GAME_WIDTH - p.currentRadius, p.x));
                p.y = Math.max(p.currentRadius, Math.min(GAME_HEIGHT - p.currentRadius, p.y));
            }
        });
    }

    function updateMechanics() {
        if (gameMode === 'ITEM') {
            if (popcornWalls.p1 > 0) popcornWalls.p1--; if (popcornWalls.p2 > 0) popcornWalls.p2--;
            if (itemSpawnTimer <= 0) {
                itemSpawnTimer = 300; itemsOnField = [];
                itemsOnField.push({ x: GAME_WIDTH * 0.2 + Math.random() * GAME_WIDTH * 0.6, y: GAME_HEIGHT * 0.3 + Math.random() * GAME_HEIGHT * 0.4, type: Math.floor(Math.random() * 6) + 1, radius: 45, tick: 0, floatY: 0 });
            } else itemSpawnTimer--;

            for (let i = itemsOnField.length - 1; i >= 0; i--) {
                let item = itemsOnField[i]; item.tick++; item.floatY = Math.sin(item.tick * 0.1) * 8; 
                [player1, player2].forEach(p => {
                    if(!p) return;
                    if (Math.hypot(p.x - item.x, p.y - item.y) < p.currentRadius + item.radius) {
                        if (item.type === 1) p.speedBuffTimer = 240; else if (item.type === 2) p.giantBuffTimer = 300; 
                        else if (item.type === 3) { if (p === player1) popcornWalls.p1 = 300; else popcornWalls.p2 = 300; }
                        else if (item.type === 4) { let op = (p === player1) ? player2 : player1; op.freezeTimer = 90; }
                        else if (item.type === 5) p.confuseTimer = 180; else if (item.type === 6) p.coffeeTimer = 180; 
                        createConfettiAt(item.x, item.y, '#FFF'); 
                        audio.playTick(); 
                        itemsOnField.splice(i, 1);
                    }
                });
            }
        }

        if (currentMap === 2) {
            if (mapState.windActive > 0) {
                mapState.windActive--;
                if (Math.random() > 0.3) { windParticles.push({ x: mapState.windDir === 1 ? -50 : GAME_WIDTH + 50, y: Math.random() * GAME_HEIGHT, vx: mapState.windDir * (25 + Math.random() * 15), vy: (Math.random() - 0.5) * 5, length: 30 + Math.random() * 50, alpha: 0.2 + Math.random() * 0.5 }); }
            } else { mapState.windTimer--; if (mapState.windTimer <= 0) { mapState.windActive = 180; mapState.windDir = Math.random() > 0.5 ? 1 : -1; mapState.windTimer = 480; showEventWarning("âš ï¸ æš´é¢¨é›ªä¾†è¥² âš ï¸"); } }
        }

        if (currentMap === 3) {
            if (mapState.lrtActive > 0) { mapState.lrtActive--; mapState.lrtX += 9; } 
            else { mapState.lrtTimer--; if (mapState.lrtTimer <= 0) { mapState.lrtActive = 180; mapState.lrtX = -850; mapState.lrtTimer = 600; showEventWarning("ğŸš† è¼•è»Œå³å°‡é€šéä¸­ç·š ğŸš†"); } }
        }

        if (currentMap === 5 && cannibalPlants.length > 0) {
            cannibalPlants.forEach(plant => {
                if (plant.cooldown > 0) plant.cooldown--;
                if (plant.eatTimer > 0) {
                    plant.eatTimer--;
                    if (plant.eatTimer === 0) {
                        if(ball) {
                            ball.isEaten = false; ball.x = plant.x; ball.y = plant.y;
                            let toCenterX = GAME_WIDTH / 2 - plant.x, toCenterY = GAME_HEIGHT / 2 - plant.y;
                            let baseAngle = Math.atan2(toCenterY, toCenterX), angleOffset = (Math.random() - 0.5) * Math.PI * 0.8; 
                            let angle = baseAngle + angleOffset;
                            let force = 55; ball.vx = Math.cos(angle) * force; ball.vy = Math.sin(angle) * force;
                            ball.homingTimer = 0; ball.fireTimer = 0; plant.cooldown = 30; shakeAmount = 25; createConfettiAt(plant.x, plant.y, '#76FF03'); 
                            audio.playKick(); 
                        }
                    } else { if(ball){ ball.x = plant.x; ball.y = plant.y; } }
                } else if (ball && !ball.isEaten && plant.cooldown === 0) {
                    let dist = Math.hypot(ball.x - plant.x, ball.y - plant.y);
                    if (dist < plant.r + ball.radius * 0.3) { ball.isEaten = true; plant.eatTimer = 90; ball.vx = 0; ball.vy = 0; shakeAmount = 15; audio.playPigHit(); }
                }
            });
        }

        if (currentMap === 6) {
            if (mapState.vortexActive > 0) {
                mapState.vortexActive--;
                if (Math.random() > 0.2) {
                    let r = 50 + Math.random() * 250; let angle = Math.random() * Math.PI * 2;
                    vortexParticles.push({ angle: angle, r: r, speed: 0.1 + Math.random() * 0.05, life: 1.0, decay: 0.02 + Math.random() * 0.03 });
                }
            } else {
                mapState.vortexTimer--;
                if (mapState.vortexTimer <= 0) { mapState.vortexActive = 180; mapState.vortexTimer = 600; showEventWarning("ğŸŒªï¸ ä¹é™é¢¨ æ—‹æ¸¦æˆå‹ ğŸŒªï¸"); }
            }
        }
    }

    // ==========================================
    // 7. ç›´æ¥åœ¨å…¨åŸŸåŸ·è¡Œåˆå§‹åŒ–èˆ‡äº‹ä»¶ç¶å®š
    // ==========================================
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d', { alpha: false });
    
    drawBeautifulBackground();
    renderLobbyPreviews();

    const handleStart = (id, x, y) => {
        if (gameState === 'LOBBY') return;
        
        if (audio.ctx && audio.ctx.state === 'suspended' && !audio.isMuted) audio.ctx.resume();

        if (y < GAME_HEIGHT / 2 && player1 && (!player1.isActive || player1.touchId === null)) { 
            player1.isActive = true; player1.touchId = id; 
            player1.joystick.active = true; player1.joystick.startX = x; player1.joystick.startY = y;
            player1.joystick.currentX = x; player1.joystick.currentY = y;
            player1.joystick.vecX = 0; player1.joystick.vecY = 0;
        }
        else if (y >= GAME_HEIGHT / 2 && player2 && (!player2.isActive || player2.touchId === null)) { 
            player2.isActive = true; player2.touchId = id; 
            player2.joystick.active = true; player2.joystick.startX = x; player2.joystick.startY = y;
            player2.joystick.currentX = x; player2.joystick.currentY = y;
            player2.joystick.vecX = 0; player2.joystick.vecY = 0;
        }
    };

    const handleMove = (id, x, y) => {
        if (player1 && player1.isActive && player1.touchId === id) { 
            player1.joystick.currentX = x; player1.joystick.currentY = y;
            let dx = x - player1.joystick.startX; 
            let dy = y - player1.joystick.startY;
            let dist = Math.hypot(dx, dy);
            let maxDist = 60; 
            
            if (dist > maxDist) dist = maxDist;
            
            if (dist > 0) {
                let ratio = dist / maxDist; 
                player1.joystick.vecX = (dx / dist) * ratio;
                player1.joystick.vecY = (dy / dist) * ratio;
            } else {
                player1.joystick.vecX = 0; player1.joystick.vecY = 0;
            }
        }
        
        if (player2 && player2.isActive && player2.touchId === id) { 
            player2.joystick.currentX = x; player2.joystick.currentY = y;
            let dx = x - player2.joystick.startX; 
            let dy = y - player2.joystick.startY;
            let dist = Math.hypot(dx, dy);
            let maxDist = 60;
            
            if (dist > maxDist) dist = maxDist;
            
            if (dist > 0) {
                let ratio = dist / maxDist;
                player2.joystick.vecX = (dx / dist) * ratio;
                player2.joystick.vecY = (dy / dist) * ratio;
            } else {
                player2.joystick.vecX = 0; player2.joystick.vecY = 0;
            }
        }
    };

    const handleEnd = (id) => {
        if (gameState === 'LOBBY') return;
        if (player1 && player1.isActive && player1.touchId === id) { 
            if (gameState === 'PLAYING') player1.kick(ball); 
            player1.isActive = false; player1.touchId = null; 
            player1.joystick.active = false; player1.joystick.vecX = 0; player1.joystick.vecY = 0;
        }
        if (player2 && player2.isActive && player2.touchId === id) { 
            if (gameState === 'PLAYING') player2.kick(ball); 
            player2.isActive = false; player2.touchId = null; 
            player2.joystick.active = false; player2.joystick.vecX = 0; player2.joystick.vecY = 0;
        }
    };

    if(canvas) {
        canvas.addEventListener('touchstart', e => { e.preventDefault(); Array.from(e.changedTouches).forEach(t => { let p = getCanvasPos(t.clientX, t.clientY); handleStart(t.identifier, p.x, p.y); }); }, {passive: false});
        canvas.addEventListener('touchmove', e => { e.preventDefault(); Array.from(e.changedTouches).forEach(t => { let p = getCanvasPos(t.clientX, t.clientY); handleMove(t.identifier, p.x, p.y); }); }, {passive: false});
        canvas.addEventListener('touchend', e => { e.preventDefault(); Array.from(e.changedTouches).forEach(t => handleEnd(t.identifier)); }, {passive: false});
        canvas.addEventListener('touchcancel', e => { e.preventDefault(); Array.from(e.changedTouches).forEach(t => handleEnd(t.identifier)); }, {passive: false});
        
        let md = false;
        canvas.addEventListener('mousedown', e => { md=true; let p = getCanvasPos(e.clientX, e.clientY); handleStart('m', p.x, p.y); });
        canvas.addEventListener('mousemove', e => { if(md){ let p = getCanvasPos(e.clientX, e.clientY); handleMove('m', p.x, p.y); } });
        window.addEventListener('mouseup', () => { if(md){ md=false; handleEnd('m'); } });
    }

    window.selectChar(1, 1);
    window.selectChar(2, 2);

    requestAnimationFrame(gameLoop);

    // ==========================================
    // 8. ä¸»éŠæˆ²è¿´åœˆ
    // ==========================================
    function gameLoop() {
        requestAnimationFrame(gameLoop);
        if (!ctx) return; 

        if (gameState === 'LOBBY') {
            if (bgCanvas) ctx.drawImage(bgCanvas, 0, 0);
            return;
        }

        try {
            ctx.fillStyle = currentMap === 6 ? '#263238' : '#2E7D32'; 
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            let dx = 0, dy = 0;
            if (shakeAmount > 0.5) { dx = (Math.random() - 0.5) * shakeAmount; dy = (Math.random() - 0.5) * shakeAmount; shakeAmount *= 0.9; }

            ctx.save(); 
            ctx.translate(dx, dy); 
            if (bgCanvas) ctx.drawImage(bgCanvas, 0, 0);

            if (gameState === 'PLAYING' || gameState === 'GOAL' || gameState === 'GAMEOVER') { updateMechanics(); }

            if (gameState === 'PLAYING') { 
                if(player1 && ball) player1.update(ball); 
                if(player2 && ball) player2.update(ball); 
                if(ball) ball.update(); 
                resolveCollisions(); 
            } else if (gameState === 'COUNTDOWN') { 
                if(player1 && ball) player1.update(ball); 
                if(player2 && ball) player2.update(ball);
                if(ball && !ball.isEaten) { ball.vx *= 0.93; ball.vy *= 0.93; ball.x += ball.vx; ball.y += ball.vy; } 
                resolveCollisions();
            }

            if (currentMap === 3 && mapState.lrtActive > 0) { drawLightRailTrain(ctx, mapState.lrtX); }
            if (popcornWalls.p1 > 0) drawPopcornWall(ctx, true); if (popcornWalls.p2 > 0) drawPopcornWall(ctx, false);
            
            if (currentMap === 4 && mushrooms.length > 0) { mushrooms.forEach(m => drawMushroom(ctx, m)); }
            if (currentMap === 5 && cannibalPlants.length > 0) { cannibalPlants.forEach(p => drawCannibalPlant(ctx, p)); }

            itemsOnField.forEach(item => drawItem(ctx, item));
            
            for(let i = shockwaves.length - 1; i >= 0; i--) {
                let sw = shockwaves[i]; sw.r += 12; sw.alpha -= 0.05;
                if (sw.alpha <= 0) { shockwaves.splice(i, 1); continue; }
                ctx.save(); ctx.beginPath(); ctx.arc(sw.x, sw.y, sw.r, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 255, 255, ${sw.alpha})`; ctx.lineWidth = 10 * sw.alpha; ctx.stroke(); ctx.restore();
            }

            if(ball) ball.draw(ctx); 
            if(player1) player1.draw(ctx); 
            if(player2) player2.draw(ctx);
            
            if (currentMap === 2) {
                for(let i = windParticles.length - 1; i >= 0; i--) {
                    let wp = windParticles[i]; wp.x += wp.vx; wp.y += wp.vy;
                    ctx.beginPath(); ctx.moveTo(wp.x, wp.y); ctx.lineTo(wp.x - wp.length * Math.sign(wp.vx), wp.y);
                    ctx.strokeStyle = `rgba(255, 255, 255, ${wp.alpha})`; ctx.lineWidth = 2; ctx.stroke();
                    if (wp.x < -150 || wp.x > GAME_WIDTH + 150) windParticles.splice(i, 1);
                }
            }

            if (currentMap === 6) {
                ctx.save(); ctx.translate(GAME_WIDTH / 2, GAME_HEIGHT / 2);
                for (let i = vortexParticles.length - 1; i >= 0; i--) {
                    let vp = vortexParticles[i]; vp.angle += vp.speed; vp.r -= 2; vp.life -= vp.decay;
                    if (vp.life <= 0 || vp.r < 10) { vortexParticles.splice(i, 1); continue; }
                    ctx.beginPath(); ctx.arc(Math.cos(vp.angle) * vp.r, Math.sin(vp.angle) * vp.r, 3, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(0, 229, 255, ${vp.life})`; ctx.fill();
                }
                ctx.restore();
            }

            if (gameState === 'GAMEOVER' && Math.random() > 0.6) { createConfettiAt(GAME_WIDTH/2 + (Math.random()-0.5)*300, GAME_HEIGHT/2 + (Math.random()-0.5)*300, `hsl(${Math.random()*360}, 80%, 60%)`); }

            for(let i=particles.length-1; i>=0; i--) {
                let p = particles[i]; p.x+=p.vx; p.y+=p.vy; p.life-=0.03;
                if (p.life<=0){ particles.splice(i,1); continue; }
                ctx.fillStyle = p.color; ctx.globalAlpha = Math.min(1, p.life); ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI*2); ctx.fill();
            }

            if(player1) player1.drawJoystick(ctx);
            if(player2) player2.drawJoystick(ctx);
            ctx.restore();

        } catch (e) {
            console.error("GameLoop Error:", e);
        }
    }

</script>

</body>
</html>
